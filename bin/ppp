#!/usr/bin/env php
<?php
switch (PHP_OS) {
case 'Windows' : define('DS', '\\'); break;
default: define('DS', '/'); break;
}

$bin_dir  = dirname(__FILE__);
$root_dir = dirname($bin_dir);
$src_dir  = $root_dir.DS.'source';
$parser   = $src_dir.DS.'parser.php';
require($parser);

// Usage string
$version = PPP_VERSION;
$help_string = <<<EOD

Usage: ppp v$version

   -f, --file <file>    Required. File to read input from. If not present, will exit
   -o, --output <file>  Optional file to write output to. If not present, will write to STDOUT
   -h, --help           Display this message

EOD;

/**
 * Helper method to write strings to a stream
 * 
 * @param handle $stream     Resource handler
 * @param string $msg        String message to write
 * @param bool   $newline    Should a new line be appended to this output
 * @access public
 * @return void
 */
function output($stream, $msg, $newline) {
    if ($newline) {
        $msg .= "\n";
    }
    fwrite($stream, $msg);

}

/**
 * Wrapper for writing output to STDERR
 * 
 * @param string $msg      String message to write
 * @param bool   $newline  Should a new line be appended to this output
 * @access public
 * @return void
 */
function err($msg, $newline=true) {
    output(STDERR, $msg, $newline);
}


/**
 * Wrapper for writing output to STDOUT
 * 
 * @param string $msg      String message to write
 * @param bool   $newline  Should a new line be appended to this output
 * @access public
 * @return void
 */
function out($msg, $newline=true) {
    output(STDOUT, $msg, $newline);
}

/**
 * Helper method for aggregating short and long values from an options
 * array, as returned from `getopt`.
 * 
 * @param array $opts Array returned from `getopt`
 * @param array $args Array of string argument names that are equivalent, ie 'h' and 'help'
 * @access public
 * @return Returns the 'true' value of these shared options, with ordered precedence
 */
function arg($opts, $args) {
    $argname = array_shift($args);

    if (!isset($opts[$argname])) {
        if (!empty($args)) {
            return call_user_func_array('arg', array($opts, $args));
        }
        return false;
    } else {
        if ($opts[$argname] === false) {
            return true;
        }
        return $opts[$argname];
    }
}

/**
 * I really hate the interface to `getopt`. This is much better.
 * Takes an array of long opts => short opts.
 * 
 * @param array $options 
 * @access public
 * @return void
 */
function getopts($options) {
    $pairs = array();
    $opt_string = '';
    $long_opts = array();
    foreach ($options as $long_opt => $short_opt) {
        $opt_string .= $short_opt;
        $long_opts[] = $long_opt;

        $long = str_replace(':', '', $long_opt);
        $short = str_replace(':', '', $short_opt);
        $pairs[$long] = array($long, $short);
    }
    $opts = getopt($opt_string, $long_opts);
    $config = array();
    foreach ($pairs as $long => $names) {
        $config[$long] = arg($opts, $names);
    }
    return $config;
}


$config = getopts(array('file:' => 'f:', 'help' => 'h', 'output:' => 'o:'));

if ($config['help']) {
    out($help_string);
    exit(0);
}

$input = null;
if (empty($config['file'])) {
    err("-f / --file argument is required!");
    exit(0);
}

$input = fopen($config['file'], 'r');
if (!$input) {
    err("Error reading input from {$config['file']}");
    exit(1);
}
$contents = stream_get_contents($input);

if (empty($contents)) {
    err("Cannot parse empty data!");
    exit(1);
}

$parser = new PPP_Parser();
$parsed = $parser->parse($contents);

if (empty($config['output'])) {
    out($parsed);
    exit(0);
}
if (file_put_contents($config['output'], $parsed)) {
    exit(0);
} else {
    err("Could not write to output file {$config['output']}");
}
